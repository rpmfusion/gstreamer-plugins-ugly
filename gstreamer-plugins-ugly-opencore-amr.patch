From 79d4b18044fa489dbebff676111d1a45afec2cff Mon Sep 17 00:00:00 2001
From: Iago Toral <itoral@igalia.com>
Date: Mon, 27 Jul 2009 18:12:20 +0000
Subject: amr: Add AMR-WB decoder and AMR-NB encoder and decoder

These are based on the OpenCore codecs.

Fixes bug #584890.
---
diff --git a/configure.ac b/configure.ac
index 764ec52..4cc9410 100644
--- a/configure.ac
+++ b/configure.ac
@@ -231,16 +231,26 @@ AG_GST_CHECK_FEATURE(A52DEC, [a52dec], a
   AC_CHECK_A52DEC(HAVE_A52DEC=yes, HAVE_A52DEC=no)
 ])
 
-dnl *** AMR-NB ***
+dnl *** amr-nb ***
 translit(dnm, m, l) AM_CONDITIONAL(USE_AMRNB, true)
-AG_GST_CHECK_FEATURE(AMRNB, [AMR-NB], amrnb, [
-  AG_GST_CHECK_LIBHEADER(AMRNB, amrnb,
+AG_GST_CHECK_FEATURE(AMRNB, [amrnb library], amrnb, [
+  AG_GST_CHECK_LIBHEADER(AMRNB, opencore-amrnb,
 		      Decoder_Interface_init, -lm,
-		      amrnb/interf_dec.h,
-		      AMRNB_LIBS="-lamrnb -lm"
+		      opencore-amrnb/interf_dec.h,
+		      AMRNB_LIBS="-lopencore-amrnb -lm"
 		      AC_SUBST(AMRNB_LIBS))
 ])
 
+dnl *** amr-wb dec ***
+translit(dnm, m, l) AM_CONDITIONAL(USE_AMRWB, true)
+AG_GST_CHECK_FEATURE(AMRWB, [amrwb library], amrwbdec, [
+  AG_GST_CHECK_LIBHEADER(AMRWB, opencore-amrwb,
+			D_IF_decode, ,
+			opencore-amrwb/dec_if.h,
+			AMRWB_LIBS="-lopencore-amrwb"
+			AC_SUBST(AMRWB_LIBS))
+])
+
 dnl *** cdio ***
 translit(dnm, m, l) AM_CONDITIONAL(USE_CDIO, true)
 AG_GST_CHECK_FEATURE(CDIO, [cdio library], cdio, [
@@ -407,6 +417,7 @@ dnl but we still need to set the conditi
 
 AM_CONDITIONAL(USE_A52DEC, false)
 AM_CONDITIONAL(USE_AMRNB, false)
+AM_CONDITIONAL(USE_AMRWB, false)
 AM_CONDITIONAL(USE_CDIO, false)
 AM_CONDITIONAL(USE_DVDREAD, false)
 AM_CONDITIONAL(USE_DVDNAV, false)
@@ -495,6 +506,7 @@ gst/synaesthesia/Makefile
 ext/Makefile
 ext/a52dec/Makefile
 ext/amrnb/Makefile
+ext/amrwbdec/Makefile
 ext/cdio/Makefile
 ext/dvdnav/Makefile
 ext/dvdread/Makefile
diff --git a/docs/plugins/Makefile.am b/docs/plugins/Makefile.am
index 1c6461a..041e004 100644
--- a/docs/plugins/Makefile.am
+++ b/docs/plugins/Makefile.am
@@ -86,7 +86,7 @@ EXTRA_HFILES = \
 	$(top_srcdir)/ext/a52dec/gsta52dec.h \
 	$(top_srcdir)/ext/amrnb/amrnbdec.h \
 	$(top_srcdir)/ext/amrnb/amrnbenc.h \
-	$(top_srcdir)/ext/amrnb/amrnbparse.h \
+	$(top_srcdir)/ext/amrwbdec/amrwbdec.h \
 	$(top_srcdir)/ext/cdio/gstcdiocddasrc.h \
 	$(top_srcdir)/ext/lame/gstlame.h \
 	$(top_srcdir)/ext/lame/gstlamemp3enc.h \
diff --git a/docs/plugins/gst-plugins-ugly-plugins-docs.sgml b/docs/plugins/gst-plugins-ugly-plugins-docs.sgml
index fbf80c9..6ed3780 100644
--- a/docs/plugins/gst-plugins-ugly-plugins-docs.sgml
+++ b/docs/plugins/gst-plugins-ugly-plugins-docs.sgml
@@ -20,7 +20,7 @@
     <xi:include href="xml/element-a52dec.xml" />
     <xi:include href="xml/element-amrnbdec.xml" />
     <xi:include href="xml/element-amrnbenc.xml" />
-    <xi:include href="xml/element-amrnbparse.xml" />
+    <xi:include href="xml/element-amrwbdec.xml" />
     <xi:include href="xml/element-cdiocddasrc.xml" />
     <xi:include href="xml/element-lame.xml" />
     <xi:include href="xml/element-lamemp3enc.xml" />
@@ -40,6 +40,7 @@
     <title>gst-plugins-ugly Plugins</title>
     <xi:include href="xml/plugin-a52dec.xml" />
     <xi:include href="xml/plugin-amrnb.xml" />
+    <xi:include href="xml/plugin-amrwbdec.xml" />
     <xi:include href="xml/plugin-asf.xml" />
     <xi:include href="xml/plugin-cdio.xml" />
     <xi:include href="xml/plugin-dvdlpcmdec.xml" />
diff --git a/docs/plugins/gst-plugins-ugly-plugins-sections.txt b/docs/plugins/gst-plugins-ugly-plugins-sections.txt
index bad7ea6..6352436 100644
--- a/docs/plugins/gst-plugins-ugly-plugins-sections.txt
+++ b/docs/plugins/gst-plugins-ugly-plugins-sections.txt
@@ -41,17 +41,17 @@ gst_amrnbenc_get_type
 </SECTION>
 
 <SECTION>
-<FILE>element-amrnbparse</FILE>
-<TITLE>amrnbparse</TITLE>
-GstAmrnbParse
-<SUBSECTION Standard>
-GstAmrnbParseClass
-GST_AMRNBPARSE
-GST_AMRNBPARSE_CLASS
-GST_IS_AMRNBPARSE
-GST_IS_AMRNBPARSE_CLASS
-GST_TYPE_AMRNBPARSE
-gst_amrnbparse_get_type
+<FILE>element-amrwbdec</FILE>
+<TITLE>amrwbdec</TITLE>
+GstAmrwbDec
+<SUBSECTION Standard>
+GstAmrwbDecClass
+GST_AMRWBDEC
+GST_AMRWBDEC_CLASS
+GST_IS_AMRWBDEC
+GST_IS_AMRWBDEC_CLASS
+GST_TYPE_AMRWBDEC
+gst_amrwbdec_get_type
 </SECTION>
 
 <SECTION>
diff --git a/docs/plugins/gst-plugins-ugly-plugins.prerequisites b/docs/plugins/gst-plugins-ugly-plugins.prerequisites
index 2bf0edd..f526a9f 100644
--- a/docs/plugins/gst-plugins-ugly-plugins.prerequisites
+++ b/docs/plugins/gst-plugins-ugly-plugins.prerequisites
@@ -1,2 +1 @@
 GstChildProxy GstObject
-GstTagSetter GstElement
diff --git a/docs/plugins/inspect/plugin-amrnb.xml b/docs/plugins/inspect/plugin-amrnb.xml
index 47cce27..d3b3a6f 100644
--- a/docs/plugins/inspect/plugin-amrnb.xml
+++ b/docs/plugins/inspect/plugin-amrnb.xml
@@ -3,10 +3,10 @@
   <description>Adaptive Multi-Rate Narrow-Band</description>
   <filename>../../ext/amrnb/.libs/libgstamrnb.so</filename>
   <basename>libgstamrnb.so</basename>
-  <version>0.10.11.1</version>
+  <version>0.10.12.1</version>
   <license>unknown</license>
   <source>gst-plugins-ugly</source>
-  <package>GStreamer Ugly Plug-ins CVS/prerelease</package>
+  <package>GStreamer Ugly Plug-ins git/prerelease</package>
   <origin>Unknown package origin</origin>
   <elements>
     <element>
@@ -51,26 +51,5 @@
         </caps>
       </pads>
     </element>
-    <element>
-      <name>amrnbparse</name>
-      <longname>AMR-NB audio stream parser</longname>
-      <class>Codec/Parser/Audio</class>
-      <description>Adaptive Multi-Rate Narrow-Band audio parser</description>
-      <author>Ronald Bultje &lt;rbultje@ronald.bitfreak.net&gt;</author>
-      <pads>
-        <caps>
-          <name>src</name>
-          <direction>source</direction>
-          <presence>always</presence>
-          <details>audio/AMR, rate=(int)8000, channels=(int)1</details>
-        </caps>
-        <caps>
-          <name>sink</name>
-          <direction>sink</direction>
-          <presence>always</presence>
-          <details>audio/x-amr-nb-sh</details>
-        </caps>
-      </pads>
-    </element>
   </elements>
 </plugin>
\ No newline at end of file
diff --git a/docs/plugins/inspect/plugin-amrwbdec.xml b/docs/plugins/inspect/plugin-amrwbdec.xml
new file mode 100644
index 0000000..5a834c0
--- a/dev/null
+++ b/docs/plugins/inspect/plugin-amrwbdec.xml
@@ -0,0 +1,34 @@
+<plugin>
+  <name>amrwbdec</name>
+  <description>Adaptive Multi-Rate Wide-Band Decoder</description>
+  <filename>../../ext/amrwbdec/.libs/libgstamrwbdec.so</filename>
+  <basename>libgstamrwbdec.so</basename>
+  <version>0.10.12.1</version>
+  <license>unknown</license>
+  <source>gst-plugins-ugly</source>
+  <package>GStreamer Ugly Plug-ins git/prerelease</package>
+  <origin>Unknown package origin</origin>
+  <elements>
+    <element>
+      <name>amrwbdec</name>
+      <longname>AMR-WB audio decoder</longname>
+      <class>Codec/Decoder/Audio</class>
+      <description>Adaptive Multi-Rate Wideband audio decoder</description>
+      <author>Renato Araujo &lt;renato.filho@indt.org.br&gt;</author>
+      <pads>
+        <caps>
+          <name>src</name>
+          <direction>source</direction>
+          <presence>always</presence>
+          <details>audio/x-raw-int, width=(int)16, depth=(int)16, signed=(boolean)true, endianness=(int)1234, rate=(int)16000, channels=(int)1</details>
+        </caps>
+        <caps>
+          <name>sink</name>
+          <direction>sink</direction>
+          <presence>always</presence>
+          <details>audio/AMR-WB, rate=(int)16000, channels=(int)1</details>
+        </caps>
+      </pads>
+    </element>
+  </elements>
+</plugin>
\ No newline at end of file
diff --git a/ext/Makefile.am b/ext/Makefile.am
index 1492093..5eaf106 100644
--- a/ext/Makefile.am
+++ b/ext/Makefile.am
@@ -10,6 +10,12 @@ else
  AMRNB_DIR =
 endif
 
+if USE_AMRWB
+ AMRWB_DIR = amrwbdec
+else
+ AMRWB_DIR =
+endif
+
 if USE_CDIO
 CDIO_DIR = cdio
 else
@@ -67,6 +73,7 @@ endif
 SUBDIRS = \
 	$(A52DEC_DIR) \
 	$(AMRNB_DIR) \
+	$(AMRWB_DIR) \
 	$(CDIO_DIR) \
 	$(DVDREAD_DIR) \
 	$(DVDNAV_DIR) \
@@ -80,6 +87,7 @@ SUBDIRS = \
 DIST_SUBDIRS = \
 	a52dec \
 	amrnb \
+	amrwbdec \
 	cdio \
 	dvdnav \
 	dvdread \
diff --git a/ext/amrnb/GstAmrnbEnc.prs b/ext/amrnb/GstAmrnbEnc.prs
new file mode 100644
index 0000000..69e3719
--- a/dev/null
+++ b/ext/amrnb/GstAmrnbEnc.prs
@@ -0,0 +1,11 @@
+[_presets_]
+version=0.10
+element-name=GstAmrnbEnc
+
+[enhance-size]
+_meta/comment=Maximize compression, lowest bitrate
+band-mode=0
+
+[enhance-quality]
+_meta/comment=Maximize quality, highest bitrate
+band-mode=7
diff --git a/ext/amrnb/Makefile.am b/ext/amrnb/Makefile.am
index 852aba6..ff0d8fe 100644
--- a/ext/amrnb/Makefile.am
+++ b/ext/amrnb/Makefile.am
@@ -3,8 +3,7 @@ plugin_LTLIBRARIES = libgstamrnb.la
 libgstamrnb_la_SOURCES = \
 	amrnb.c \
 	amrnbdec.c \
-	amrnbenc.c \
-	amrnbparse.c
+	amrnbenc.c
 
 libgstamrnb_la_CFLAGS = $(GST_CFLAGS) $(AMRNB_CFLAGS)
 libgstamrnb_la_LIBADD = $(GST_BASE_LIBS) $(AMRNB_LIBS)
@@ -13,5 +12,9 @@ libgstamrnb_la_LIBTOOLFLAGS = --tag=disable-static
 
 noinst_HEADERS = \
 	amrnbdec.h \
-	amrnbenc.h \
-	amrnbparse.h
+	amrnbenc.h
+
+presetdir = $(datadir)/gstreamer-$(GST_MAJORMINOR)/presets
+preset_DATA = GstAmrnbEnc.prs
+
+EXTRA_DIST = $(preset_DATA)
diff --git a/ext/amrnb/README b/ext/amrnb/README
new file mode 100644
index 0000000..879dbe7
--- a/dev/null
+++ b/ext/amrnb/README
@@ -0,0 +1,6 @@
+Compiling AMRNB:
+================
+
+To compile the amrnb plugin, you need the opencore-amrnb development package.
+If your distribution does not provide this package, you can download the 
+source code from "http://sourceforge.net/projects/opencore-amr".
diff --git a/ext/amrnb/amrnb.c b/ext/amrnb/amrnb.c
index c614b17..3e88645 100644
--- a/ext/amrnb/amrnb.c
+++ b/ext/amrnb/amrnb.c
@@ -23,15 +23,12 @@
 
 #include "amrnbdec.h"
 #include "amrnbenc.h"
-#include "amrnbparse.h"
 
 static gboolean
 plugin_init (GstPlugin * plugin)
 {
   return gst_element_register (plugin, "amrnbdec",
       GST_RANK_PRIMARY, GST_TYPE_AMRNBDEC) &&
-      gst_element_register (plugin, "amrnbparse",
-      GST_RANK_PRIMARY, GST_TYPE_AMRNBPARSE) &&
       gst_element_register (plugin, "amrnbenc",
       GST_RANK_NONE, GST_TYPE_AMRNBENC);
 }
diff --git a/ext/amrnb/amrnbdec.c b/ext/amrnb/amrnbdec.c
index ba45ea6..4c48a37 100644
--- a/ext/amrnb/amrnbdec.c
+++ b/ext/amrnb/amrnbdec.c
@@ -19,15 +19,15 @@
 
 /**
  * SECTION:element-amrnbdec
- * @see_also: #GstAmrnbEnc, #GstAmrnbParse
+ * @see_also: #GstAmrnbEnc, #GstAmrParse
  *
  * AMR narrowband decoder based on the 
- * <ulink url="http://www.penguin.cz/~utx/amr">reference codec implementation</ulink>.
+ * <ulink url="http://sourceforge.net/projects/opencore-amr">opencore codec implementation</ulink>.
  * 
  * <refsect2>
  * <title>Example launch line</title>
  * |[
- * gst-launch filesrc location=abc.amr ! amrnbparse ! amrnbdec ! audioresample ! audioconvert ! alsasink
+ * gst-launch filesrc location=abc.amr ! amrparse ! amrnbdec ! audioresample ! audioconvert ! alsasink
  * ]|
  * </refsect2>
  */
@@ -61,6 +61,7 @@ GST_DEBUG_CATEGORY_STATIC (gst_amrnbdec_debug);
 static const gint block_size_if1[16] = { 12, 13, 15, 17, 19, 20, 26, 31, 5,
   0, 0, 0, 0, 0, 0, 0
 };
+
 static const gint block_size_if2[16] = { 12, 13, 15, 17, 18, 20, 25, 30, 5,
   0, 0, 0, 0, 0, 0, 0
 };
diff --git a/ext/amrnb/amrnbdec.h b/ext/amrnb/amrnbdec.h
index 08a5201..785935b 100644
--- a/ext/amrnb/amrnbdec.h
+++ b/ext/amrnb/amrnbdec.h
@@ -22,7 +22,7 @@
 
 #include <gst/gst.h>
 #include <gst/base/gstadapter.h>
-#include <amrnb/interf_dec.h>
+#include <opencore-amrnb/interf_dec.h>
 
 G_BEGIN_DECLS
 
diff --git a/ext/amrnb/amrnbenc.c b/ext/amrnb/amrnbenc.c
index 2d2a16b..43db015 100644
--- a/ext/amrnb/amrnbenc.c
+++ b/ext/amrnb/amrnbenc.c
@@ -22,7 +22,7 @@
  * @see_also: #GstAmrnbDec, #GstAmrnbParse
  *
  * AMR narrowband encoder based on the 
- * <ulink url="http://www.penguin.cz/~utx/amr">reference codec implementation</ulink>.
+ * <ulink url="http://sourceforge.net/projects/opencore-amr">opencore codec implementation</ulink>.
  * 
  * <refsect2>
  * <title>Example launch line</title>
@@ -99,8 +99,21 @@ static gboolean gst_amrnbenc_setcaps (GstPad * pad, GstCaps * caps);
 static GstStateChangeReturn gst_amrnbenc_state_change (GstElement * element,
     GstStateChange transition);
 
-#define _do_init(bla) \
-    GST_DEBUG_CATEGORY_INIT (gst_amrnbenc_debug, "amrnbenc", 0, "AMR-NB audio encoder");
+static void
+_do_init (GType object_type)
+{
+  const GInterfaceInfo preset_interface_info = {
+    NULL,                       /* interface init */
+    NULL,                       /* interface finalize */
+    NULL                        /* interface_data */
+  };
+
+  g_type_add_interface_static (object_type, GST_TYPE_PRESET,
+      &preset_interface_info);
+
+  GST_DEBUG_CATEGORY_INIT (gst_amrnbenc_debug, "amrnbenc", 0,
+      "AMR-NB audio encoder");
+}
 
 GST_BOILERPLATE_FULL (GstAmrnbEnc, gst_amrnbenc, GstElement, GST_TYPE_ELEMENT,
     _do_init);
diff --git a/ext/amrnb/amrnbenc.h b/ext/amrnb/amrnbenc.h
index 64306dc..f4ea414 100644
--- a/ext/amrnb/amrnbenc.h
+++ b/ext/amrnb/amrnbenc.h
@@ -21,7 +21,7 @@
 #define __GST_AMRNBENC_H__
 
 #include <gst/gst.h>
-#include <amrnb/interf_enc.h>
+#include <opencore-amrnb/interf_enc.h>
 #include <gst/base/gstadapter.h>
 
 G_BEGIN_DECLS
diff --git a/ext/amrnb/amrnbparse.c b/ext/amrnb/amrnbparse.c
deleted file mode 100644
index 6bcdad8..0000000
--- a/ext/amrnb/amrnbparse.c
+++ b/dev/null
@@ -1,784 +0,0 @@
-/* GStreamer Adaptive Multi-Rate Narrow-Band (AMR-NB) plugin
- * Copyright (C) 2004 Ronald Bultje <rbultje@ronald.bitfreak.net>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-/**
- * SECTION:element-amrnbparse
- * @see_also: #GstAmrnbDec, #GstAmrnbEnc
- *
- * AMR narrowband bitstream parser.
- * 
- * <refsect2>
- * <title>Example launch line</title>
- * |[
- * gst-launch filesrc location=abc.amr ! amrnbparse ! amrnbdec ! audioresample ! audioconvert ! alsasink
- * ]|
- * </refsect2>
- */
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include <string.h>
-#include "amrnbparse.h"
-
-static GstStaticPadTemplate src_template = GST_STATIC_PAD_TEMPLATE ("src",
-    GST_PAD_SRC,
-    GST_PAD_ALWAYS,
-    GST_STATIC_CAPS ("audio/AMR, " "rate = (int) 8000, " "channels = (int) 1")
-    );
-
-static GstStaticPadTemplate sink_template = GST_STATIC_PAD_TEMPLATE ("sink",
-    GST_PAD_SINK,
-    GST_PAD_ALWAYS,
-    GST_STATIC_CAPS ("audio/x-amr-nb-sh")
-    );
-
-GST_DEBUG_CATEGORY_STATIC (gst_amrnbparse_debug);
-#define GST_CAT_DEFAULT gst_amrnbparse_debug
-
-static const gint block_size[16] = { 12, 13, 15, 17, 19, 20, 26, 31, 5,
-  0, 0, 0, 0, 0, 0, 0
-};
-
-#define AMRNB_HEADER_SIZE 6
-#define AMRNB_HEADER_STR "#!AMR\n"
-
-/*static const GstFormat *gst_amrnbparse_formats (GstPad * pad);*/
-static const GstQueryType *gst_amrnbparse_querytypes (GstPad * pad);
-static gboolean gst_amrnbparse_query (GstPad * pad, GstQuery * query);
-
-static gboolean gst_amrnbparse_sink_event (GstPad * pad, GstEvent * event);
-static gboolean gst_amrnbparse_src_event (GstPad * pad, GstEvent * event);
-static GstFlowReturn gst_amrnbparse_chain (GstPad * pad, GstBuffer * buffer);
-static void gst_amrnbparse_loop (GstPad * pad);
-static gboolean gst_amrnbparse_sink_activate (GstPad * sinkpad);
-static gboolean gst_amrnbparse_sink_activate_pull (GstPad * sinkpad,
-    gboolean active);
-static gboolean gst_amrnbparse_sink_activate_push (GstPad * sinkpad,
-    gboolean active);
-static GstStateChangeReturn gst_amrnbparse_state_change (GstElement * element,
-    GstStateChange transition);
-
-static void gst_amrnbparse_finalize (GObject * object);
-
-#define _do_init(bla) \
-    GST_DEBUG_CATEGORY_INIT (gst_amrnbparse_debug, "amrnbparse", 0, "AMR-NB audio stream parser");
-
-GST_BOILERPLATE_FULL (GstAmrnbParse, gst_amrnbparse, GstElement,
-    GST_TYPE_ELEMENT, _do_init);
-
-static void
-gst_amrnbparse_base_init (gpointer klass)
-{
-  GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
-  GstElementDetails details = GST_ELEMENT_DETAILS ("AMR-NB audio stream parser",
-      "Codec/Parser/Audio",
-      "Adaptive Multi-Rate Narrow-Band audio parser",
-      "Ronald Bultje <rbultje@ronald.bitfreak.net>");
-
-  gst_element_class_add_pad_template (element_class,
-      gst_static_pad_template_get (&sink_template));
-  gst_element_class_add_pad_template (element_class,
-      gst_static_pad_template_get (&src_template));
-
-  gst_element_class_set_details (element_class, &details);
-}
-
-static void
-gst_amrnbparse_class_init (GstAmrnbParseClass * klass)
-{
-  GObjectClass *object_class = G_OBJECT_CLASS (klass);
-  GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
-
-  object_class->finalize = gst_amrnbparse_finalize;
-
-  element_class->change_state = GST_DEBUG_FUNCPTR (gst_amrnbparse_state_change);
-}
-
-static void
-gst_amrnbparse_init (GstAmrnbParse * amrnbparse, GstAmrnbParseClass * klass)
-{
-  /* create the sink pad */
-  amrnbparse->sinkpad =
-      gst_pad_new_from_static_template (&sink_template, "sink");
-  gst_pad_set_chain_function (amrnbparse->sinkpad,
-      GST_DEBUG_FUNCPTR (gst_amrnbparse_chain));
-  gst_pad_set_event_function (amrnbparse->sinkpad,
-      GST_DEBUG_FUNCPTR (gst_amrnbparse_sink_event));
-  gst_pad_set_activate_function (amrnbparse->sinkpad,
-      gst_amrnbparse_sink_activate);
-  gst_pad_set_activatepull_function (amrnbparse->sinkpad,
-      gst_amrnbparse_sink_activate_pull);
-  gst_pad_set_activatepush_function (amrnbparse->sinkpad,
-      gst_amrnbparse_sink_activate_push);
-  gst_element_add_pad (GST_ELEMENT (amrnbparse), amrnbparse->sinkpad);
-
-  /* create the src pad */
-  amrnbparse->srcpad = gst_pad_new_from_static_template (&src_template, "src");
-  gst_pad_set_event_function (amrnbparse->srcpad,
-      GST_DEBUG_FUNCPTR (gst_amrnbparse_src_event));
-  gst_pad_set_query_function (amrnbparse->srcpad,
-      GST_DEBUG_FUNCPTR (gst_amrnbparse_query));
-  gst_pad_set_query_type_function (amrnbparse->srcpad,
-      GST_DEBUG_FUNCPTR (gst_amrnbparse_querytypes));
-  gst_pad_use_fixed_caps (amrnbparse->srcpad);
-  gst_element_add_pad (GST_ELEMENT (amrnbparse), amrnbparse->srcpad);
-
-  amrnbparse->adapter = gst_adapter_new ();
-
-  /* init rest */
-  amrnbparse->ts = 0;
-}
-
-static void
-gst_amrnbparse_finalize (GObject * object)
-{
-  GstAmrnbParse *amrnbparse;
-
-  amrnbparse = GST_AMRNBPARSE (object);
-
-  gst_adapter_clear (amrnbparse->adapter);
-  g_object_unref (amrnbparse->adapter);
-
-  G_OBJECT_CLASS (parent_class)->finalize (object);
-}
-
-
-/*
- * Position querying.
- */
-
-#if 0
-static const GstFormat *
-gst_amrnbparse_formats (GstPad * pad)
-{
-  static const GstFormat list[] = {
-    GST_FORMAT_TIME,
-    0
-  };
-
-  return list;
-}
-#endif
-
-static const GstQueryType *
-gst_amrnbparse_querytypes (GstPad * pad)
-{
-  static const GstQueryType list[] = {
-    GST_QUERY_POSITION,
-    GST_QUERY_DURATION,
-    0
-  };
-
-  return list;
-}
-
-static gboolean
-gst_amrnbparse_query (GstPad * pad, GstQuery * query)
-{
-  GstAmrnbParse *amrnbparse;
-  gboolean res = TRUE;
-
-  amrnbparse = GST_AMRNBPARSE (GST_PAD_PARENT (pad));
-
-  switch (GST_QUERY_TYPE (query)) {
-    case GST_QUERY_POSITION:
-    {
-      GstFormat format;
-      gint64 cur;
-
-      gst_query_parse_position (query, &format, NULL);
-
-      if (format != GST_FORMAT_TIME)
-        return FALSE;
-
-      cur = amrnbparse->ts;
-
-      gst_query_set_position (query, GST_FORMAT_TIME, cur);
-      res = TRUE;
-      break;
-    }
-    case GST_QUERY_DURATION:
-    {
-      GstFormat format;
-      gint64 tot;
-      GstPad *peer;
-
-      gst_query_parse_duration (query, &format, NULL);
-
-      if (format != GST_FORMAT_TIME)
-        return FALSE;
-
-      tot = -1;
-      res = FALSE;
-
-      peer = gst_pad_get_peer (amrnbparse->sinkpad);
-      if (peer) {
-        GstFormat pformat;
-        gint64 ptot;
-
-        pformat = GST_FORMAT_BYTES;
-        res = gst_pad_query_duration (peer, &pformat, &ptot);
-        if (res && amrnbparse->block) {
-          tot =
-              gst_util_uint64_scale_int (ptot, 20 * GST_MSECOND,
-              amrnbparse->block);
-        }
-        gst_object_unref (GST_OBJECT (peer));
-      }
-      gst_query_set_duration (query, GST_FORMAT_TIME, tot);
-      break;
-    }
-    default:
-      res = gst_pad_query_default (pad, query);
-      break;
-  }
-  return res;
-}
-
-
-static gboolean
-gst_amrnbparse_handle_pull_seek (GstAmrnbParse * amrnbparse, GstPad * pad,
-    GstEvent * event)
-{
-  GstFormat format;
-  gdouble rate;
-  GstSeekFlags flags;
-  GstSeekType cur_type, stop_type;
-  gint64 cur, stop;
-  gint64 byte_cur = -1;
-  gboolean flush;
-
-  gst_event_parse_seek (event, &rate, &format, &flags, &cur_type, &cur,
-      &stop_type, &stop);
-
-  GST_DEBUG_OBJECT (amrnbparse, "Performing seek to %" GST_TIME_FORMAT,
-      GST_TIME_ARGS (cur));
-
-  /* For any format other than TIME, see if upstream handles
-   * it directly or fail. For TIME, try upstream, but do it ourselves if
-   * it fails upstream */
-  if (format != GST_FORMAT_TIME) {
-    return gst_pad_push_event (amrnbparse->sinkpad, event);
-  } else {
-    if (gst_pad_push_event (amrnbparse->sinkpad, event))
-      return TRUE;
-  }
-
-  flush = flags & GST_SEEK_FLAG_FLUSH;
-
-  /* send flush start */
-  if (flush)
-    gst_pad_push_event (amrnbparse->sinkpad, gst_event_new_flush_start ());
-  /* we only handle FLUSH seeks at the moment */
-  else
-    return FALSE;
-
-  /* grab streaming lock, this should eventually be possible, either
-   * because the task is paused or our streaming thread stopped
-   * because our peer is flushing. */
-  GST_PAD_STREAM_LOCK (amrnbparse->sinkpad);
-
-  /* Convert the TIME to the appropriate BYTE position at which to resume
-   * decoding. */
-  cur = cur / (20 * GST_MSECOND) * (20 * GST_MSECOND);
-  if (cur != -1)
-    byte_cur = amrnbparse->block * (cur / 20 / GST_MSECOND) + AMRNB_HEADER_SIZE;
-  amrnbparse->offset = byte_cur;
-  amrnbparse->ts = cur;
-
-  GST_DEBUG_OBJECT (amrnbparse, "Seeking to byte range %" G_GINT64_FORMAT,
-      byte_cur);
-
-  /* and prepare to continue streaming */
-  /* send flush stop, peer will accept data and events again. We
-   * are not yet providing data as we still have the STREAM_LOCK. */
-  gst_pad_push_event (amrnbparse->sinkpad, gst_event_new_flush_stop ());
-  gst_pad_push_event (amrnbparse->srcpad, gst_event_new_new_segment (FALSE,
-          rate, format, cur, -1, cur));
-
-  /* and restart the task in case it got paused explicitely or by
-   * the FLUSH_START event we pushed out. */
-  gst_pad_start_task (amrnbparse->sinkpad,
-      (GstTaskFunction) gst_amrnbparse_loop, amrnbparse->sinkpad);
-
-  /* and release the lock again so we can continue streaming */
-  GST_PAD_STREAM_UNLOCK (amrnbparse->sinkpad);
-
-  return TRUE;
-}
-
-static gboolean
-gst_amrnbparse_handle_push_seek (GstAmrnbParse * amrnbparse, GstPad * pad,
-    GstEvent * event)
-{
-  GstFormat format;
-  gdouble rate;
-  GstSeekFlags flags;
-  GstSeekType cur_type, stop_type;
-  gint64 cur, stop;
-  gint64 byte_cur = -1, byte_stop = -1;
-
-  gst_event_parse_seek (event, &rate, &format, &flags, &cur_type, &cur,
-      &stop_type, &stop);
-
-  GST_DEBUG_OBJECT (amrnbparse, "Performing seek to %" GST_TIME_FORMAT,
-      GST_TIME_ARGS (cur));
-
-  /* For any format other than TIME, see if upstream handles
-   * it directly or fail. For TIME, try upstream, but do it ourselves if
-   * it fails upstream */
-  if (format != GST_FORMAT_TIME) {
-    return gst_pad_push_event (amrnbparse->sinkpad, event);
-  } else {
-    if (gst_pad_push_event (amrnbparse->sinkpad, event))
-      return TRUE;
-  }
-
-  /* Convert the TIME to the appropriate BYTE position at which to resume
-   * decoding. */
-  cur = cur / (20 * GST_MSECOND) * (20 * GST_MSECOND);
-  if (cur != -1)
-    byte_cur = amrnbparse->block * (cur / 20 / GST_MSECOND) + AMRNB_HEADER_SIZE;
-  if (stop != -1)
-    byte_stop =
-        amrnbparse->block * (stop / 20 / GST_MSECOND) + AMRNB_HEADER_SIZE;
-  amrnbparse->ts = cur;
-
-  GST_DEBUG_OBJECT (amrnbparse, "Seeking to byte range %" G_GINT64_FORMAT
-      " to %" G_GINT64_FORMAT, byte_cur, byte_stop);
-
-  /* Send BYTE based seek upstream */
-  event = gst_event_new_seek (rate, GST_FORMAT_BYTES, flags, cur_type,
-      byte_cur, stop_type, byte_stop);
-
-  return gst_pad_push_event (amrnbparse->sinkpad, event);
-}
-
-static gboolean
-gst_amrnbparse_src_event (GstPad * pad, GstEvent * event)
-{
-  GstAmrnbParse *amrnbparse = GST_AMRNBPARSE (gst_pad_get_parent (pad));
-  gboolean res;
-
-  GST_DEBUG_OBJECT (amrnbparse, "handling event %d", GST_EVENT_TYPE (event));
-
-  switch (GST_EVENT_TYPE (event)) {
-    case GST_EVENT_SEEK:
-      if (amrnbparse->seek_handler)
-        res = amrnbparse->seek_handler (amrnbparse, pad, event);
-      else
-        res = FALSE;
-      break;
-    default:
-      res = gst_pad_push_event (amrnbparse->sinkpad, event);
-      break;
-  }
-  gst_object_unref (amrnbparse);
-
-  return res;
-}
-
-/*
- * Data reading.
- */
-static gboolean
-gst_amrnbparse_sink_event (GstPad * pad, GstEvent * event)
-{
-  GstAmrnbParse *amrnbparse;
-  gboolean res;
-
-  amrnbparse = GST_AMRNBPARSE (gst_pad_get_parent (pad));
-
-  GST_LOG ("handling event %d", GST_EVENT_TYPE (event));
-
-  switch (GST_EVENT_TYPE (event)) {
-    case GST_EVENT_FLUSH_START:
-      res = gst_pad_push_event (amrnbparse->srcpad, event);
-      break;
-    case GST_EVENT_FLUSH_STOP:
-      gst_adapter_clear (amrnbparse->adapter);
-      gst_segment_init (&amrnbparse->segment, GST_FORMAT_TIME);
-      res = gst_pad_push_event (amrnbparse->srcpad, event);
-      break;
-    case GST_EVENT_EOS:
-      res = gst_pad_push_event (amrnbparse->srcpad, event);
-      break;
-    case GST_EVENT_NEWSEGMENT:
-    {
-      /* eat for now, we send a newsegment at start with infinite
-       * duration. */
-      gst_event_unref (event);
-      res = TRUE;
-      break;
-    }
-    default:
-      res = gst_pad_push_event (amrnbparse->srcpad, event);
-      break;
-  }
-  gst_object_unref (amrnbparse);
-
-  return res;
-}
-
-/* streaming mode */
-static GstFlowReturn
-gst_amrnbparse_chain (GstPad * pad, GstBuffer * buffer)
-{
-  GstAmrnbParse *amrnbparse;
-  GstFlowReturn res;
-  gint mode;
-  const guint8 *data;
-  GstBuffer *out;
-  GstClockTime timestamp;
-
-  amrnbparse = GST_AMRNBPARSE (GST_PAD_PARENT (pad));
-
-  timestamp = GST_BUFFER_TIMESTAMP (buffer);
-  if (GST_CLOCK_TIME_IS_VALID (timestamp)) {
-    GST_DEBUG_OBJECT (amrnbparse, "Lock on timestamp %" GST_TIME_FORMAT,
-        GST_TIME_ARGS (timestamp));
-    amrnbparse->ts = timestamp;
-  }
-
-  gst_adapter_push (amrnbparse->adapter, buffer);
-
-  res = GST_FLOW_OK;
-
-  /* init */
-  if (amrnbparse->need_header) {
-    GstEvent *segev;
-    GstCaps *caps;
-
-    if (gst_adapter_available (amrnbparse->adapter) < AMRNB_HEADER_SIZE)
-      goto done;
-
-    data = gst_adapter_peek (amrnbparse->adapter, AMRNB_HEADER_SIZE);
-    if (memcmp (data, AMRNB_HEADER_STR, AMRNB_HEADER_SIZE) != 0)
-      goto done;
-
-    gst_adapter_flush (amrnbparse->adapter, AMRNB_HEADER_SIZE);
-
-    amrnbparse->need_header = FALSE;
-
-    caps = gst_caps_new_simple ("audio/AMR",
-        "rate", G_TYPE_INT, 8000, "channels", G_TYPE_INT, 1, NULL);
-    gst_pad_set_caps (amrnbparse->srcpad, caps);
-    gst_caps_unref (caps);
-
-    GST_DEBUG_OBJECT (amrnbparse, "Sending first segment");
-    segev = gst_event_new_new_segment_full (FALSE, 1.0, 1.0,
-        GST_FORMAT_TIME, 0, -1, 0);
-
-    gst_pad_push_event (amrnbparse->srcpad, segev);
-  }
-
-  while (TRUE) {
-    if (gst_adapter_available (amrnbparse->adapter) < 1)
-      break;
-    data = gst_adapter_peek (amrnbparse->adapter, 1);
-
-    /* get size */
-    mode = (data[0] >> 3) & 0x0F;
-    amrnbparse->block = block_size[mode] + 1;   /* add one for the mode */
-
-    if (gst_adapter_available (amrnbparse->adapter) < amrnbparse->block)
-      break;
-
-    out = gst_buffer_new_and_alloc (amrnbparse->block);
-
-    data = gst_adapter_peek (amrnbparse->adapter, amrnbparse->block);
-    memcpy (GST_BUFFER_DATA (out), data, amrnbparse->block);
-
-    /* timestamp, all constants that won't overflow */
-    GST_BUFFER_DURATION (out) = GST_SECOND * 160 / 8000;
-    GST_BUFFER_TIMESTAMP (out) = amrnbparse->ts;
-    if (GST_CLOCK_TIME_IS_VALID (amrnbparse->ts))
-      amrnbparse->ts += GST_BUFFER_DURATION (out);
-
-    gst_buffer_set_caps (out, GST_PAD_CAPS (amrnbparse->srcpad));
-
-    GST_DEBUG_OBJECT (amrnbparse, "Pushing %d bytes of data",
-        amrnbparse->block);
-    res = gst_pad_push (amrnbparse->srcpad, out);
-
-    gst_adapter_flush (amrnbparse->adapter, amrnbparse->block);
-  }
-done:
-
-  return res;
-}
-
-static gboolean
-gst_amrnbparse_pull_header (GstAmrnbParse * amrnbparse)
-{
-  GstBuffer *buffer;
-  GstFlowReturn ret;
-  guint8 *data;
-  gint size;
-
-  ret = gst_pad_pull_range (amrnbparse->sinkpad, G_GUINT64_CONSTANT (0),
-      AMRNB_HEADER_SIZE, &buffer);
-  if (ret != GST_FLOW_OK)
-    return FALSE;
-
-  data = GST_BUFFER_DATA (buffer);
-  size = GST_BUFFER_SIZE (buffer);
-  if (size < AMRNB_HEADER_SIZE)
-    goto not_enough;
-
-  if (memcmp (data, AMRNB_HEADER_STR, AMRNB_HEADER_SIZE))
-    goto no_header;
-
-  gst_buffer_unref (buffer);
-
-  amrnbparse->offset = AMRNB_HEADER_SIZE;
-  return TRUE;
-
-not_enough:
-  {
-    gst_buffer_unref (buffer);
-    return FALSE;
-  }
-no_header:
-  {
-    gst_buffer_unref (buffer);
-    return FALSE;
-  }
-}
-
-/* random access mode, could just read a fixed size buffer and push it to
- * the chain function but we don't... */
-static void
-gst_amrnbparse_loop (GstPad * pad)
-{
-  GstAmrnbParse *amrnbparse;
-  GstBuffer *buffer;
-  guint8 *data;
-  gint size;
-  gint mode;
-  GstFlowReturn ret;
-
-  amrnbparse = GST_AMRNBPARSE (GST_PAD_PARENT (pad));
-
-  /* init */
-  if (G_UNLIKELY (amrnbparse->need_header)) {
-    GstCaps *caps;
-
-    if (!gst_amrnbparse_pull_header (amrnbparse)) {
-      GST_ELEMENT_ERROR (amrnbparse, STREAM, WRONG_TYPE, (NULL), (NULL));
-      GST_LOG_OBJECT (amrnbparse, "could not read header");
-      goto need_pause;
-    }
-
-    caps = gst_caps_new_simple ("audio/AMR",
-        "rate", G_TYPE_INT, 8000, "channels", G_TYPE_INT, 1, NULL);
-    gst_pad_set_caps (amrnbparse->srcpad, caps);
-    gst_caps_unref (caps);
-
-    GST_DEBUG_OBJECT (amrnbparse, "Sending newsegment event");
-    gst_pad_push_event (amrnbparse->srcpad,
-        gst_event_new_new_segment_full (FALSE, 1.0, 1.0,
-            GST_FORMAT_TIME, 0, -1, 0));
-
-    amrnbparse->need_header = FALSE;
-  }
-
-  ret =
-      gst_pad_pull_range (amrnbparse->sinkpad, amrnbparse->offset, 1, &buffer);
-
-  if (ret == GST_FLOW_UNEXPECTED)
-    goto eos;
-  else if (ret != GST_FLOW_OK)
-    goto need_pause;
-
-  data = GST_BUFFER_DATA (buffer);
-  size = GST_BUFFER_SIZE (buffer);
-
-  /* EOS */
-  if (size < 1) {
-    gst_buffer_unref (buffer);
-    goto eos;
-  }
-
-  /* get size */
-  mode = (data[0] >> 3) & 0x0F;
-  amrnbparse->block = block_size[mode] + 1;     /* add one for the mode */
-
-  gst_buffer_unref (buffer);
-
-  ret =
-      gst_pad_pull_range (amrnbparse->sinkpad, amrnbparse->offset,
-      amrnbparse->block, &buffer);
-
-  if (ret == GST_FLOW_UNEXPECTED)
-    goto eos;
-  else if (ret != GST_FLOW_OK)
-    goto need_pause;
-
-  if (GST_BUFFER_SIZE (buffer) < amrnbparse->block) {
-    gst_buffer_unref (buffer);
-    goto eos;
-  }
-
-  amrnbparse->offset += amrnbparse->block;
-
-  /* output */
-  buffer = gst_buffer_make_metadata_writable (buffer);
-  GST_BUFFER_DURATION (buffer) = GST_SECOND * 160 / 8000;
-  GST_BUFFER_TIMESTAMP (buffer) = amrnbparse->ts;
-
-  gst_buffer_set_caps (buffer, GST_PAD_CAPS (amrnbparse->srcpad));
-
-  GST_DEBUG_OBJECT (amrnbparse, "Pushing %2d bytes, ts=%" GST_TIME_FORMAT,
-      amrnbparse->block, GST_TIME_ARGS (amrnbparse->ts));
-
-  ret = gst_pad_push (amrnbparse->srcpad, buffer);
-
-  if (G_UNLIKELY (ret != GST_FLOW_OK)) {
-    GST_DEBUG_OBJECT (amrnbparse, "Flow: %s", gst_flow_get_name (ret));
-    if (GST_FLOW_IS_FATAL (ret) || ret == GST_FLOW_NOT_LINKED) {
-      if (ret == GST_FLOW_UNEXPECTED) {
-        /* we don't do seeking yet, so no segment flag to check here either */
-        if (0) {
-          /* post segment_done message here one day when seeking works */
-        } else {
-          GST_LOG_OBJECT (amrnbparse, "Sending EOS at end of segment");
-          gst_pad_push_event (amrnbparse->srcpad, gst_event_new_eos ());
-        }
-      } else {
-        GST_ELEMENT_ERROR (amrnbparse, STREAM, FAILED, (NULL),
-            ("streaming stopped, reason: %s", gst_flow_get_name (ret)));
-        gst_pad_push_event (amrnbparse->srcpad, gst_event_new_eos ());
-      }
-    }
-    goto need_pause;
-  }
-
-  amrnbparse->ts += GST_BUFFER_DURATION (buffer);
-
-  return;
-
-need_pause:
-  {
-    GST_LOG_OBJECT (amrnbparse, "pausing task");
-    gst_pad_pause_task (pad);
-    return;
-  }
-eos:
-  {
-    GST_LOG_OBJECT (amrnbparse, "pausing task (eos)");
-    gst_pad_push_event (amrnbparse->srcpad, gst_event_new_eos ());
-    gst_pad_pause_task (pad);
-    return;
-  }
-}
-
-static gboolean
-gst_amrnbparse_sink_activate (GstPad * sinkpad)
-{
-  gboolean result = FALSE;
-  GstAmrnbParse *amrnbparse;
-
-  amrnbparse = GST_AMRNBPARSE (gst_pad_get_parent (sinkpad));
-
-  if (gst_pad_check_pull_range (sinkpad)) {
-    GST_DEBUG ("Trying to activate in pull mode");
-    amrnbparse->seekable = TRUE;
-    amrnbparse->ts = 0;
-    result = gst_pad_activate_pull (sinkpad, TRUE);
-  } else {
-    GST_DEBUG ("Try to activate in push mode");
-    amrnbparse->seekable = FALSE;
-    result = gst_pad_activate_push (sinkpad, TRUE);
-  }
-
-  gst_object_unref (amrnbparse);
-  return result;
-}
-
-static gboolean
-gst_amrnbparse_sink_activate_push (GstPad * sinkpad, gboolean active)
-{
-  GstAmrnbParse *amrnbparse = GST_AMRNBPARSE (gst_pad_get_parent (sinkpad));
-
-  if (active) {
-    amrnbparse->seek_handler = gst_amrnbparse_handle_push_seek;
-  } else {
-    amrnbparse->seek_handler = NULL;
-  }
-
-  gst_object_unref (amrnbparse);
-  return TRUE;
-}
-
-static gboolean
-gst_amrnbparse_sink_activate_pull (GstPad * sinkpad, gboolean active)
-{
-  gboolean result;
-  GstAmrnbParse *amrnbparse = GST_AMRNBPARSE (gst_pad_get_parent (sinkpad));
-
-  if (active) {
-    amrnbparse->seek_handler = gst_amrnbparse_handle_pull_seek;
-    result = gst_pad_start_task (sinkpad,
-        (GstTaskFunction) gst_amrnbparse_loop, sinkpad);
-  } else {
-    amrnbparse->seek_handler = NULL;
-    result = gst_pad_stop_task (sinkpad);
-  }
-
-  gst_object_unref (amrnbparse);
-  return result;
-}
-
-static GstStateChangeReturn
-gst_amrnbparse_state_change (GstElement * element, GstStateChange transition)
-{
-  GstAmrnbParse *amrnbparse;
-  GstStateChangeReturn ret;
-
-  amrnbparse = GST_AMRNBPARSE (element);
-
-  switch (transition) {
-    case GST_STATE_CHANGE_NULL_TO_READY:
-      break;
-    case GST_STATE_CHANGE_READY_TO_PAUSED:
-      amrnbparse->need_header = TRUE;
-      amrnbparse->ts = -1;
-      amrnbparse->block = 0;
-      gst_segment_init (&amrnbparse->segment, GST_FORMAT_TIME);
-      break;
-    default:
-      break;
-  }
-
-  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
-
-  switch (transition) {
-    case GST_STATE_CHANGE_PAUSED_TO_READY:
-      break;
-    case GST_STATE_CHANGE_READY_TO_NULL:
-      break;
-    default:
-      break;
-  }
-
-  return ret;
-}
diff --git a/ext/amrnb/amrnbparse.h b/ext/amrnb/amrnbparse.h
deleted file mode 100644
index a5d61c4..0000000
--- a/ext/amrnb/amrnbparse.h
+++ b/dev/null
@@ -1,75 +0,0 @@
-/* GStreamer Adaptive Multi-Rate Narrow-Band (AMR-NB) plugin
- * Copyright (C) 2004 Ronald Bultje <rbultje@ronald.bitfreak.net>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifndef __GST_AMRNBPARSE_H__
-#define __GST_AMRNBPARSE_H__
-
-#include <gst/gst.h>
-#include <gst/base/gstadapter.h>
-
-G_BEGIN_DECLS
-
-#define GST_TYPE_AMRNBPARSE \
-  (gst_amrnbparse_get_type())
-#define GST_AMRNBPARSE(obj) \
-  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_AMRNBPARSE, GstAmrnbParse))
-#define GST_AMRNBPARSE_CLASS(klass) \
-  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_AMRNBPARSE, GstAmrnbParseClass))
-#define GST_IS_AMRNBPARSE(obj) \
-  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_AMRNBPARSE))
-#define GST_IS_AMRNBPARSE_CLASS(klass) \
-  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_AMRNBPARSE))
-
-typedef struct _GstAmrnbParse GstAmrnbParse;
-typedef struct _GstAmrnbParseClass GstAmrnbParseClass;
-
-typedef gboolean (*GstAmrnbSeekHandler) (GstAmrnbParse * amrnbparse, GstPad * pad,
-		    GstEvent * event);
-
-
-struct _GstAmrnbParse {
-  GstElement element;
-
-  /* pads */
-  GstPad *sinkpad, *srcpad;
-
-  GstAdapter *adapter;
-
-  gboolean seekable;
-  gboolean need_header;
-  gint64 offset;
-  gint block;
-
-  GstAmrnbSeekHandler seek_handler;
-
-  guint64 ts;
-
-  /* for seeking etc */
-  GstSegment segment;
-};
-
-struct _GstAmrnbParseClass {
-  GstElementClass parent_class;
-};
-
-GType gst_amrnbparse_get_type (void);
-
-G_END_DECLS
-
-#endif /* __GST_AMRNBPARSE_H__ */
diff --git a/ext/amrwbdec/Makefile.am b/ext/amrwbdec/Makefile.am
new file mode 100644
index 0000000..236cfa0
--- a/dev/null
+++ b/ext/amrwbdec/Makefile.am
@@ -0,0 +1,13 @@
+plugin_LTLIBRARIES = libgstamrwbdec.la
+
+libgstamrwbdec_la_SOURCES = \
+	amrwb.c \
+	amrwbdec.c
+
+libgstamrwbdec_la_CFLAGS = $(GST_CFLAGS) $(AMRWB_CFLAGS)
+libgstamrwbdec_la_LIBADD = $(GST_BASE_LIBS) $(AMRWB_LIBS)
+libgstamrwbdec_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
+libgstamrwbdec_la_LIBTOOLFLAGS = --tag=disable-static
+
+noinst_HEADERS = \
+	amrwbdec.h
diff --git a/ext/amrwbdec/README b/ext/amrwbdec/README
new file mode 100644
index 0000000..835adef
--- a/dev/null
+++ b/ext/amrwbdec/README
@@ -0,0 +1,6 @@
+Compiling AMRWB decoder:
+========================
+
+To compile the amrwbdec plugin, you need the opencore-amrwb development
+package. If your distribution does not provide this package, you can
+download the source code from "http://sourceforge.net/projects/opencore-amr".
diff --git a/ext/amrwbdec/amrwb.c b/ext/amrwbdec/amrwb.c
new file mode 100644
index 0000000..0bf1958
--- a/dev/null
+++ b/ext/amrwbdec/amrwb.c
@@ -0,0 +1,39 @@
+/* GStreamer Adaptive Multi-Rate Wide-Band (AMR-WB) Decoder plugin
+ * Copyright (C) 2006 Edgard Lima <edgard.lima@indt.org.br>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "amrwbdec.h"
+
+static gboolean
+plugin_init (GstPlugin * plugin)
+{
+  return gst_element_register (plugin, "amrwbdec",
+      GST_RANK_NONE, GST_TYPE_AMRWBDEC);
+}
+
+
+GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
+    GST_VERSION_MINOR,
+    "amrwbdec",
+    "Adaptive Multi-Rate Wide-Band Decoder",
+    plugin_init, VERSION, GST_LICENSE_UNKNOWN, GST_PACKAGE_NAME,
+    GST_PACKAGE_ORIGIN);
diff --git a/ext/amrwbdec/amrwbdec.c b/ext/amrwbdec/amrwbdec.c
new file mode 100644
index 0000000..8292bf0
--- a/dev/null
+++ b/ext/amrwbdec/amrwbdec.c
@@ -0,0 +1,375 @@
+/* GStreamer Adaptive Multi-Rate Narrow-Band (AMR-NB) plugin
+ * Copyright (C) 2004 Ronald Bultje <rbultje@ronald.bitfreak.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/**
+ * SECTION:element-amrwbdec
+ * @see_also: #GstAmrwbEnc
+ *
+ * AMR wideband decoder based on the 
+ * <ulink url="http://sourceforge.net/projects/opencore-amr">opencore codec implementation</ulink>.
+ *
+ * <refsect2>
+ * <title>Example launch line</title>
+ * |[
+ * gst-launch filesrc location=abc.amr ! amrparse ! amrwbdec ! audioresample ! audioconvert ! alsasink
+ * ]|
+ * </refsect2>
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "amrwbdec.h"
+
+static GstStaticPadTemplate sink_template = GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("audio/AMR-WB, "
+        "rate = (int) 16000, " "channels = (int) 1")
+    );
+
+static GstStaticPadTemplate src_template = GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("audio/x-raw-int, "
+        "width = (int) 16, "
+        "depth = (int) 16, "
+        "signed = (boolean) TRUE, "
+        "endianness = (int) BYTE_ORDER, "
+        "rate = (int) 16000, " "channels = (int) 1")
+    );
+
+GST_DEBUG_CATEGORY_STATIC (gst_amrwbdec_debug);
+#define GST_CAT_DEFAULT gst_amrwbdec_debug
+
+static const unsigned char block_size[16] =
+    { 18, 24, 33, 37, 41, 47, 51, 59, 61,
+  6, 6, 0, 0, 0, 1, 1
+};
+
+static gboolean gst_amrwbdec_event (GstPad * pad, GstEvent * event);
+static GstFlowReturn gst_amrwbdec_chain (GstPad * pad, GstBuffer * buffer);
+static gboolean gst_amrwbdec_setcaps (GstPad * pad, GstCaps * caps);
+static GstStateChangeReturn gst_amrwbdec_state_change (GstElement * element,
+    GstStateChange transition);
+
+static void gst_amrwbdec_finalize (GObject * object);
+
+#define _do_init(bla) \
+    GST_DEBUG_CATEGORY_INIT (gst_amrwbdec_debug, "amrwbdec", 0, "AMR-WB audio decoder");
+
+GST_BOILERPLATE_FULL (GstAmrwbDec, gst_amrwbdec, GstElement, GST_TYPE_ELEMENT,
+    _do_init);
+
+static void
+gst_amrwbdec_base_init (gpointer klass)
+{
+  GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
+  GstElementDetails details = GST_ELEMENT_DETAILS ("AMR-WB audio decoder",
+      "Codec/Decoder/Audio",
+      "Adaptive Multi-Rate Wideband audio decoder",
+      "Renato Araujo <renato.filho@indt.org.br>");
+
+  gst_element_class_add_pad_template (element_class,
+      gst_static_pad_template_get (&sink_template));
+  gst_element_class_add_pad_template (element_class,
+      gst_static_pad_template_get (&src_template));
+
+  gst_element_class_set_details (element_class, &details);
+}
+
+static void
+gst_amrwbdec_class_init (GstAmrwbDecClass * klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+  GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
+
+  object_class->finalize = gst_amrwbdec_finalize;
+
+  element_class->change_state = GST_DEBUG_FUNCPTR (gst_amrwbdec_state_change);
+}
+
+static void
+gst_amrwbdec_init (GstAmrwbDec * amrwbdec, GstAmrwbDecClass * klass)
+{
+  /* create the sink pad */
+  amrwbdec->sinkpad = gst_pad_new_from_static_template (&sink_template, "sink");
+  gst_pad_set_setcaps_function (amrwbdec->sinkpad, gst_amrwbdec_setcaps);
+  gst_pad_set_event_function (amrwbdec->sinkpad, gst_amrwbdec_event);
+  gst_pad_set_chain_function (amrwbdec->sinkpad, gst_amrwbdec_chain);
+  gst_element_add_pad (GST_ELEMENT (amrwbdec), amrwbdec->sinkpad);
+
+  /* create the src pad */
+  amrwbdec->srcpad = gst_pad_new_from_static_template (&src_template, "src");
+  gst_pad_use_fixed_caps (amrwbdec->srcpad);
+  gst_element_add_pad (GST_ELEMENT (amrwbdec), amrwbdec->srcpad);
+
+  amrwbdec->adapter = gst_adapter_new ();
+
+  /* init rest */
+  amrwbdec->handle = NULL;
+  amrwbdec->channels = 0;
+  amrwbdec->rate = 0;
+  amrwbdec->duration = 0;
+  amrwbdec->ts = -1;
+}
+
+static void
+gst_amrwbdec_finalize (GObject * object)
+{
+  GstAmrwbDec *amrwbdec;
+
+  amrwbdec = GST_AMRWBDEC (object);
+
+  gst_adapter_clear (amrwbdec->adapter);
+  g_object_unref (amrwbdec->adapter);
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static gboolean
+gst_amrwbdec_setcaps (GstPad * pad, GstCaps * caps)
+{
+  GstStructure *structure;
+  GstAmrwbDec *amrwbdec;
+  GstCaps *copy;
+
+  amrwbdec = GST_AMRWBDEC (gst_pad_get_parent (pad));
+
+  structure = gst_caps_get_structure (caps, 0);
+
+  /* get channel count */
+  gst_structure_get_int (structure, "channels", &amrwbdec->channels);
+  gst_structure_get_int (structure, "rate", &amrwbdec->rate);
+
+  /* create reverse caps */
+  copy = gst_caps_new_simple ("audio/x-raw-int",
+      "channels", G_TYPE_INT, amrwbdec->channels,
+      "width", G_TYPE_INT, 16,
+      "depth", G_TYPE_INT, 16,
+      "endianness", G_TYPE_INT, G_BYTE_ORDER,
+      "rate", G_TYPE_INT, amrwbdec->rate, "signed", G_TYPE_BOOLEAN, TRUE, NULL);
+
+  amrwbdec->duration = gst_util_uint64_scale_int (GST_SECOND, L_FRAME16k,
+      amrwbdec->rate * amrwbdec->channels);
+
+  gst_pad_set_caps (amrwbdec->srcpad, copy);
+  gst_caps_unref (copy);
+
+  gst_object_unref (amrwbdec);
+
+  return TRUE;
+}
+
+static gboolean
+gst_amrwbdec_event (GstPad * pad, GstEvent * event)
+{
+  GstAmrwbDec *amrwbdec;
+  gboolean ret = TRUE;
+
+  amrwbdec = GST_AMRWBDEC (gst_pad_get_parent (pad));
+
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_FLUSH_START:
+      ret = gst_pad_push_event (amrwbdec->srcpad, event);
+      break;
+    case GST_EVENT_FLUSH_STOP:
+      ret = gst_pad_push_event (amrwbdec->srcpad, event);
+      gst_adapter_clear (amrwbdec->adapter);
+      amrwbdec->ts = -1;
+      break;
+    case GST_EVENT_EOS:
+      gst_adapter_clear (amrwbdec->adapter);
+      ret = gst_pad_push_event (amrwbdec->srcpad, event);
+      break;
+    case GST_EVENT_NEWSEGMENT:
+    {
+      GstFormat format;
+      gdouble rate, arate;
+      gint64 start, stop, time;
+      gboolean update;
+
+      gst_event_parse_new_segment_full (event, &update, &rate, &arate, &format,
+          &start, &stop, &time);
+
+      /* we need time for now */
+      if (format != GST_FORMAT_TIME)
+        goto newseg_wrong_format;
+
+      GST_DEBUG_OBJECT (amrwbdec,
+          "newsegment: update %d, rate %g, arate %g, start %" GST_TIME_FORMAT
+          ", stop %" GST_TIME_FORMAT ", time %" GST_TIME_FORMAT,
+          update, rate, arate, GST_TIME_ARGS (start), GST_TIME_ARGS (stop),
+          GST_TIME_ARGS (time));
+
+      /* now configure the values */
+      gst_segment_set_newsegment_full (&amrwbdec->segment, update,
+          rate, arate, format, start, stop, time);
+      ret = gst_pad_push_event (amrwbdec->srcpad, event);
+    }
+      break;
+    default:
+      ret = gst_pad_push_event (amrwbdec->srcpad, event);
+      break;
+  }
+done:
+  gst_object_unref (amrwbdec);
+
+  return ret;
+
+  /* ERRORS */
+newseg_wrong_format:
+  {
+    GST_DEBUG_OBJECT (amrwbdec, "received non TIME newsegment");
+    goto done;
+  }
+}
+
+static GstFlowReturn
+gst_amrwbdec_chain (GstPad * pad, GstBuffer * buffer)
+{
+  GstAmrwbDec *amrwbdec;
+  GstFlowReturn ret = GST_FLOW_OK;
+
+  amrwbdec = GST_AMRWBDEC (gst_pad_get_parent (pad));
+
+  if (amrwbdec->rate == 0 || amrwbdec->channels == 0)
+    goto not_negotiated;
+
+  /* discontinuity, don't combine samples before and after the
+   * DISCONT */
+  if (GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_DISCONT)) {
+    gst_adapter_clear (amrwbdec->adapter);
+    amrwbdec->ts = -1;
+    amrwbdec->discont = TRUE;
+  }
+
+  /* take latest timestamp, FIXME timestamp is the one of the
+   * first buffer in the adapter. */
+  if (GST_BUFFER_TIMESTAMP_IS_VALID (buffer))
+    amrwbdec->ts = GST_BUFFER_TIMESTAMP (buffer);
+
+  gst_adapter_push (amrwbdec->adapter, buffer);
+
+  while (TRUE) {
+    GstBuffer *out;
+    const guint8 *data;
+    gint block, mode;
+
+    /* need to peek data to get the size */
+    if (gst_adapter_available (amrwbdec->adapter) < 1)
+      break;
+    data = gst_adapter_peek (amrwbdec->adapter, 1);
+
+    /* get size */
+    mode = (data[0] >> 3) & 0x0F;
+    block = block_size[mode];
+
+    GST_DEBUG_OBJECT (amrwbdec, "mode %d, block %d", mode, block);
+
+    if (!block || gst_adapter_available (amrwbdec->adapter) < block)
+      break;
+
+    /* the library seems to write into the source data, hence the copy. */
+    data = gst_adapter_take (amrwbdec->adapter, block);
+
+    /* get output */
+    out = gst_buffer_new_and_alloc (sizeof (gint16) * L_FRAME16k);
+
+    GST_BUFFER_DURATION (out) = amrwbdec->duration;
+    GST_BUFFER_TIMESTAMP (out) = amrwbdec->ts;
+
+    if (amrwbdec->ts != -1)
+      amrwbdec->ts += amrwbdec->duration;
+    if (amrwbdec->discont) {
+      GST_BUFFER_FLAG_SET (out, GST_BUFFER_FLAG_DISCONT);
+      amrwbdec->discont = FALSE;
+    }
+
+    gst_buffer_set_caps (out, GST_PAD_CAPS (amrwbdec->srcpad));
+
+    /* decode */
+    D_IF_decode (amrwbdec->handle, (unsigned char *) data,
+        (Word16 *) GST_BUFFER_DATA (out), _good_frame);
+
+    g_free ((gpointer) data);
+
+    /* send out */
+    ret = gst_pad_push (amrwbdec->srcpad, out);
+  }
+
+  gst_object_unref (amrwbdec);
+  return ret;
+
+  /* ERRORS */
+not_negotiated:
+  {
+    GST_ELEMENT_ERROR (amrwbdec, STREAM, TYPE_NOT_FOUND, (NULL),
+        ("Decoder is not initialized"));
+    gst_object_unref (amrwbdec);
+    return GST_FLOW_NOT_NEGOTIATED;
+  }
+}
+
+static GstStateChangeReturn
+gst_amrwbdec_state_change (GstElement * element, GstStateChange transition)
+{
+  GstAmrwbDec *amrwbdec;
+  GstStateChangeReturn ret;
+
+  amrwbdec = GST_AMRWBDEC (element);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_NULL_TO_READY:
+      if (!(amrwbdec->handle = D_IF_init ()))
+        goto init_failed;
+      break;
+    case GST_STATE_CHANGE_READY_TO_PAUSED:
+      gst_adapter_clear (amrwbdec->adapter);
+      amrwbdec->rate = 0;
+      amrwbdec->channels = 0;
+      amrwbdec->ts = -1;
+      amrwbdec->discont = TRUE;
+      gst_segment_init (&amrwbdec->segment, GST_FORMAT_TIME);
+      break;
+    default:
+      break;
+  }
+
+  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_READY_TO_NULL:
+      D_IF_exit (amrwbdec->handle);
+      break;
+    default:
+      break;
+  }
+
+  return ret;
+
+  /* ERRORS */
+init_failed:
+  {
+    GST_ELEMENT_ERROR (amrwbdec, LIBRARY, INIT, (NULL),
+        ("Failed to open AMR Decoder"));
+    return GST_STATE_CHANGE_FAILURE;
+  }
+}
diff --git a/ext/amrwbdec/amrwbdec.h b/ext/amrwbdec/amrwbdec.h
new file mode 100644
index 0000000..750c618
--- a/dev/null
+++ b/ext/amrwbdec/amrwbdec.h
@@ -0,0 +1,79 @@
+/* GStreamer Adaptive Multi-Rate Wide-Band (AMR-WB) plugin
+ * Copyright (C) 2006 Edgard Lima <edgard.lima@indt.org.br>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GST_AMRWBDEC_H__
+#define __GST_AMRWBDEC_H__
+
+#include <gst/gst.h>
+#include <gst/base/gstadapter.h>
+#include <opencore-amrwb/dec_if.h>
+#include <opencore-amrwb/if_rom.h>
+
+#define L_FRAME16k      320   /* Frame size at 16kHz  */
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_AMRWBDEC			\
+  (gst_amrwbdec_get_type())
+#define GST_AMRWBDEC(obj)						\
+  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_AMRWBDEC, GstAmrwbDec))
+#define GST_AMRWBDEC_CLASS(klass)					\
+  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_AMRWBDEC, GstAmrwbDecClass))
+#define GST_IS_AMRWBDEC(obj)					\
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_AMRWBDEC))
+#define GST_IS_AMRWBDEC_CLASS(klass)			\
+  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_AMRWBDEC))
+
+typedef struct _GstAmrwbDec GstAmrwbDec;
+typedef struct _GstAmrwbDecClass GstAmrwbDecClass;
+
+/**
+ * GstAmrwbDec:
+ *
+ * Opaque data structure.
+ */
+struct _GstAmrwbDec {
+  GstElement element;
+
+  /* pads */
+  GstPad *sinkpad, *srcpad;
+  guint64 ts;
+
+  GstAdapter *adapter;
+
+  /* library handle */
+  void *handle;
+
+  /* output settings */
+  gint channels, rate;
+  gint duration;
+
+  GstSegment        segment;
+  gboolean          discont;
+};
+
+struct _GstAmrwbDecClass {
+  GstElementClass parent_class;
+};
+
+GType gst_amrwbdec_get_type (void);
+
+G_END_DECLS
+
+#endif /* __GST_AMRWBDEC_H__ */
--
cgit v0.8.2
