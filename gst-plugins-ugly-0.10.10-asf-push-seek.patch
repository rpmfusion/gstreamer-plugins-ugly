diff -up gst-plugins-ugly-0.10.10/gst/asfdemux/asfpacket.c.push-seek gst-plugins-ugly-0.10.10/gst/asfdemux/asfpacket.c
--- gst-plugins-ugly-0.10.10/gst/asfdemux/asfpacket.c.push-seek	2009-01-25 11:24:31.000000000 +0100
+++ gst-plugins-ugly-0.10.10/gst/asfdemux/asfpacket.c	2009-01-25 12:51:48.000000000 +0100
@@ -127,6 +127,11 @@ gst_asf_payload_queue_for_stream (GstASF
     GST_DEBUG_OBJECT (demux, "first ts: %" GST_TIME_FORMAT,
         GST_TIME_ARGS (payload->ts));
     demux->first_ts = payload->ts;
+    if (demux->push_mode) {
+      gst_segment_set_seek (&demux->segment, demux->segment.rate,
+        GST_FORMAT_TIME, demux->segment.flags, GST_SEEK_TYPE_SET,
+        demux->first_ts, GST_SEEK_TYPE_NONE, 0, NULL);
+    }
   }
 
   /* better drop a few frames at the beginning than send bogus timestamps */
@@ -140,7 +145,8 @@ gst_asf_payload_queue_for_stream (GstASF
   }
 
   /* make timestamps start from 0 */
-  payload->ts -= demux->first_ts;
+  if (!demux->push_mode)
+    payload->ts -= demux->first_ts;
 
   /* remove any incomplete payloads that will never be completed */
   while (stream->payloads->len > 0) {
diff -up gst-plugins-ugly-0.10.10/gst/asfdemux/gstasfdemux.c.push-seek gst-plugins-ugly-0.10.10/gst/asfdemux/gstasfdemux.c
--- gst-plugins-ugly-0.10.10/gst/asfdemux/gstasfdemux.c.push-seek	2009-01-25 11:24:56.000000000 +0100
+++ gst-plugins-ugly-0.10.10/gst/asfdemux/gstasfdemux.c	2009-01-25 12:54:31.000000000 +0100
@@ -23,9 +23,6 @@
  * - _loop():
  *   stop if at end of segment if != end of file, ie. demux->segment.stop
  *
- * - _chain(): fix newsegment events for live streams where timestamps don't
- *   start at zero (need sample files/streams for this)
- *
  * - fix packet parsing:
  *   there's something wrong with timestamps for packets with keyframes,
  *   and durations too.
@@ -264,6 +261,7 @@ gst_asf_demux_activate_push (GstPad * si
 
   demux = GST_ASF_DEMUX (GST_OBJECT_PARENT (sinkpad));
 
+  demux->push_mode = TRUE;
   demux->state = GST_ASF_DEMUX_STATE_HEADER;
   demux->streaming = TRUE;
 
@@ -276,6 +274,7 @@ gst_asf_demux_activate_pull (GstPad * pa
   GstASFDemux *demux;
 
   demux = GST_ASF_DEMUX (GST_OBJECT_PARENT (pad));
+  demux->push_mode = FALSE;
 
   if (active) {
     demux->state = GST_ASF_DEMUX_STATE_HEADER;
@@ -313,8 +312,17 @@ gst_asf_demux_sink_event (GstPad * pad, 
       }
 
       GST_OBJECT_LOCK (demux);
+      if (demux->packet_size && newsegment_start > demux->data_offset)
+        demux->packet = (newsegment_start - demux->data_offset) /
+                        demux->packet_size;
+      else
+        demux->packet = 0;
+      demux->first_ts = GST_CLOCK_TIME_NONE;
+      demux->need_newsegment = TRUE;
       gst_asf_demux_reset_stream_state_after_discont (demux);
       GST_OBJECT_UNLOCK (demux);
+
+      gst_event_unref (event);
       break;
     }
     case GST_EVENT_EOS:{
@@ -331,6 +339,14 @@ gst_asf_demux_sink_event (GstPad * pad, 
       break;
     }
 
+    case GST_EVENT_FLUSH_START:
+    case GST_EVENT_FLUSH_STOP:
+      GST_OBJECT_LOCK (demux);
+      gst_asf_demux_reset_stream_state_after_discont (demux);
+      GST_OBJECT_UNLOCK (demux);
+      gst_asf_demux_send_event_unlocked (demux, event);
+      break;
+
     default:
       ret = gst_pad_event_default (pad, event);
       break;
@@ -450,6 +466,11 @@ gst_asf_demux_handle_seek_event (GstASFD
   accurate = ((flags & GST_SEEK_FLAG_ACCURATE) == GST_SEEK_FLAG_ACCURATE);
   keyunit_sync = ((flags & GST_SEEK_FLAG_KEY_UNIT) == GST_SEEK_FLAG_KEY_UNIT);
 
+  if (demux->push_mode) {
+    gst_event_ref (event);
+    return gst_pad_push_event (demux->sinkpad, event);
+  }
+
   /* unlock the streaming thread */
   if (flush) {
     gst_pad_push_event (demux->sinkpad, gst_event_new_flush_start ());
diff -up gst-plugins-ugly-0.10.10/gst/asfdemux/gstasfdemux.h.push-seek gst-plugins-ugly-0.10.10/gst/asfdemux/gstasfdemux.h
--- gst-plugins-ugly-0.10.10/gst/asfdemux/gstasfdemux.h.push-seek	2009-01-25 12:52:19.000000000 +0100
+++ gst-plugins-ugly-0.10.10/gst/asfdemux/gstasfdemux.h	2009-01-25 12:52:55.000000000 +0100
@@ -171,6 +171,7 @@ struct _GstASFDemux {
   gboolean             need_newsegment;  /* do we need to send a new-segment event? */
   gboolean             segment_running;  /* if we've started the current segment    */
   gboolean             streaming;        /* TRUE if we are operating chain-based    */
+  gboolean             push_mode;        /* are we operating in push_mode? */
 
   /* Descrambler settings */
   guint8               span;
